#!/bin/bash

# cargo-check-hook.sh
# Extracts warnings and errors from cargo check output for Claude hooks

set -e

# Parse command line arguments
HOOK_TYPE=""
DENY_WARNINGS=false
while [[ $# -gt 0 ]]; do
    case $1 in
        --pre)
            HOOK_TYPE="pre"
            shift
            ;;
        --post)
            HOOK_TYPE="post"
            shift
            ;;
        --deny-warnings)
            DENY_WARNINGS=true
            shift
            ;;
        *)
            PROJECT_DIR="$1"
            shift
            ;;
    esac
done

# Default to current directory if no project specified
PROJECT_DIR="${PROJECT_DIR:-.}"

# Create temp directory for storing results
TEMP_DIR=$(mktemp -d)
trap "rm -rf $TEMP_DIR" EXIT

# Run cargo check with JSON output
run_cargo_check() {
    cd "$PROJECT_DIR"
    cargo check --all-targets --message-format=json 2>&1 || true
}

# Parse cargo output and collect diagnostics
parse_cargo_output() {
    local has_errors="false"
    local has_warnings="false"
    local error_count=0
    local warning_count=0
    local diagnostics_array=()
    
    while IFS= read -r line; do
        # Check if line is valid JSON
        if echo "$line" | jq empty 2>/dev/null; then
            # Extract compiler messages
            if echo "$line" | jq -e '.reason == "compiler-message"' >/dev/null 2>&1; then
                local level=$(echo "$line" | jq -r '.message.level')
                local message=$(echo "$line" | jq -r '.message.message')
                local code=$(echo "$line" | jq -r '.message.code.code // "unknown"')
                
                # Extract file location
                local file_name=$(echo "$line" | jq -r '.message.spans[0].file_name // "unknown"')
                local line_start=$(echo "$line" | jq -r '.message.spans[0].line_start // 0')
                local line_end=$(echo "$line" | jq -r '.message.spans[0].line_end // 0')
                local column_start=$(echo "$line" | jq -r '.message.spans[0].column_start // 0')
                local column_end=$(echo "$line" | jq -r '.message.spans[0].column_end // 0')
                
                # Count errors and warnings
                if [ "$level" = "error" ]; then
                    has_errors="true"
                    ((error_count++))
                elif [ "$level" = "warning" ]; then
                    has_warnings="true"
                    ((warning_count++))
                fi
                
                # Build diagnostic JSON object
                local diagnostic_json=$(jq -n \
                    --arg severity "$level" \
                    --arg code "$code" \
                    --arg message "$message" \
                    --arg file "$file_name" \
                    --argjson line_start "$line_start" \
                    --argjson line_end "$line_end" \
                    --argjson column_start "$column_start" \
                    --argjson column_end "$column_end" \
                    '{
                        severity: $severity,
                        code: $code,
                        message: $message,
                        location: {
                            file: $file,
                            range: {
                                start: {line: $line_start, column: $column_start},
                                end: {line: $line_end, column: $column_end}
                            }
                        }
                    }')
                
                # Add suggestion if available
                if echo "$line" | jq -e '.message.children[0].spans[0].suggested_replacement' >/dev/null 2>&1; then
                    local suggestion=$(echo "$line" | jq -r '.message.children[0].spans[0].suggested_replacement')
                    if [ -n "$suggestion" ]; then
                        diagnostic_json=$(echo "$diagnostic_json" | jq --arg sugg "$suggestion" '. + {suggestion: $sugg}')
                    fi
                fi
                
                diagnostics_array+=("$diagnostic_json")
            fi
        fi
    done
    
    # Combine all diagnostics into a JSON array and save to file
    if [ ${#diagnostics_array[@]} -gt 0 ]; then
        printf '%s\n' "${diagnostics_array[@]}" | jq -s '.' > "$TEMP_DIR/diagnostics.json"
    else
        echo "[]" > "$TEMP_DIR/diagnostics.json"
    fi
    
    # Save summary to file
    cat > "$TEMP_DIR/summary.json" <<EOF
{
    "has_errors": $has_errors,
    "has_warnings": $has_warnings,
    "error_count": $error_count,
    "warning_count": $warning_count
}
EOF
}

# Build the response object (diagnostics + summary)
build_response() {
    local diagnostics=$(cat "$TEMP_DIR/diagnostics.json")
    local summary=$(cat "$TEMP_DIR/summary.json")
    
    jq -n \
        --argjson diagnostics "$diagnostics" \
        --argjson summary "$summary" \
        '{
            diagnostics: $diagnostics,
            summary: $summary
        }' > "$TEMP_DIR/response.json"
}

# Format output for Claude pre-hook
format_pre_hook() {
    local response=$(cat "$TEMP_DIR/response.json")
    local summary=$(cat "$TEMP_DIR/summary.json")
    
    local has_errors=$(echo "$summary" | jq -r '.has_errors')
    local has_warnings=$(echo "$summary" | jq -r '.has_warnings')
    local error_count=$(echo "$summary" | jq -r '.error_count')
    local warning_count=$(echo "$summary" | jq -r '.warning_count')
    
    local decision=""
    local reason=""
    
    # Determine decision and reason
    if [ "$has_errors" = "true" ]; then
        decision="block"
        reason="Code has $error_count compilation error(s) that must be fixed"
    elif [ "$has_warnings" = "true" ] && [ "$DENY_WARNINGS" = "true" ]; then
        decision="block"
        reason="Code has $warning_count warning(s) and --deny-warnings is enabled"
    elif [ "$has_warnings" = "true" ] && [ "$warning_count" -gt 5 ]; then
        decision="block"
        reason="Too many warnings ($warning_count) - code quality issues detected"
    elif [ "$has_warnings" = "true" ]; then
        # undefined means allow
        reason="Code has $warning_count warning(s) but proceeding"
    else
        reason="Code check passed successfully"
    fi
    
    # Build the hook response
    if [ -n "$decision" ]; then
        jq -n \
            --arg decision "$decision" \
            --arg reason "$reason" \
            --argjson response "$response" \
            '{
                decision: $decision,
                reason: $reason,
                hookSpecificOutput: {
                    hookEventName: "PreToolUse",
                    additionalContext: $response
                }
            }'
    else
        jq -n \
            --arg reason "$reason" \
            --argjson response "$response" \
            '{
                reason: $reason,
                hookSpecificOutput: {
                    hookEventName: "PreToolUse",
                    additionalContext: $response
                }
            }'
    fi
}

# Format output for Claude post-hook
format_post_hook() {
    local response=$(cat "$TEMP_DIR/response.json")
    local summary=$(cat "$TEMP_DIR/summary.json")
    
    local has_errors=$(echo "$summary" | jq -r '.has_errors')
    local has_warnings=$(echo "$summary" | jq -r '.has_warnings')
    local error_count=$(echo "$summary" | jq -r '.error_count')
    local warning_count=$(echo "$summary" | jq -r '.warning_count')
    
    local decision=""
    local reason=""
    
    # Determine decision and reason
    if [ "$has_errors" = "true" ]; then
        decision="block"
        reason="Compilation failed with $error_count error(s)"
    elif [ "$has_warnings" = "true" ] && [ "$DENY_WARNINGS" = "true" ]; then
        decision="block"
        reason="Code has $warning_count warning(s) and --deny-warnings is enabled"
    elif [ "$has_warnings" = "true" ] && [ "$warning_count" -gt 5 ]; then
        decision="block"
        reason="Too many warnings ($warning_count) - code quality issues detected"
    elif [ "$has_warnings" = "true" ]; then
        reason="Code compiled with $warning_count warning(s)"
    else
        reason="Code compiled successfully without issues"
    fi
    
    # Build the hook response
    if [ -n "$decision" ]; then
        jq -n \
            --arg decision "$decision" \
            --arg reason "$reason" \
            --argjson response "$response" \
            '{
                decision: $decision,
                reason: $reason,
                hookSpecificOutput: {
                    hookEventName: "PostToolUse",
                    additionalContext: $response
                }
            }'
    else
        jq -n \
            --arg reason "$reason" \
            --argjson response "$response" \
            '{
                reason: $reason,
                hookSpecificOutput: {
                    hookEventName: "PostToolUse",
                    additionalContext: $response
                }
            }'
    fi
}

# Format standard output (no hook type specified)
format_standard() {
    cat "$TEMP_DIR/response.json" | jq '.'
}

# Main execution
main() {
    # Run cargo check and parse output silently
    run_cargo_check 2>/dev/null | parse_cargo_output
    
    # Build response object
    build_response
    
    # Format output based on hook type
    case "$HOOK_TYPE" in
        pre)
            format_pre_hook
            ;;
        post)
            format_post_hook
            ;;
        *)
            format_standard
            ;;
    esac
    
    # Determine exit code
    local summary=$(cat "$TEMP_DIR/summary.json")
    local has_errors=$(echo "$summary" | jq -r '.has_errors')
    local has_warnings=$(echo "$summary" | jq -r '.has_warnings')
    
    if [ "$has_errors" = "true" ]; then
        exit 2
    elif [ "$has_warnings" = "true" ] && [ "$DENY_WARNINGS" = "true" ]; then
        exit 2
    else
        exit 0
    fi
}

# Check if jq is installed
if ! command -v jq &> /dev/null; then
    echo '{"decision": "block", "reason": "jq is required but not installed"}' 
    exit 1
fi

# Check if cargo is installed
if ! command -v cargo &> /dev/null; then
    echo '{"decision": "block", "reason": "cargo is required but not installed"}'
    exit 1
fi

# Run main function
main
